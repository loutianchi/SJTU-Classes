# HW3

### 插入操作

![image-20240321104432699](C:\Users\LEGION\AppData\Roaming\Typora\typora-user-images\image-20240321104432699.png)

### 问答

#### 如何理解Splay的均摊时间复杂度

Splay的摊还时间复杂度是指，尽管某些操作在特定情况下有很高的时间复杂度，但它们的代价会分摊到其他时间复杂度低的操作中，从而使总体的时间复杂度维持在较低的水准。在Splay中，所有的操作都依赖于将一个节点旋转到根来实现，因此这是Splay树的主要开销，其他如插入、覆盖等操作（常数级别的）就可以被忽略。因此只需要分析旋转到根的操作即可。

对旋转到根的操作，分为 zig, zig-zig, zig-zag，而对这三种情况进行摊还分析以后就可以得到一个上界 logN，取一个势能函数  φ(T) = Σ log Size(des) = Σ Rank(des), 用这个函数来计算以上三种操作的开销，然后将其累加就可以得到总体的开销。可以用 Rank_i(X) - Rank_i-1(X) 乘一个常数作为一个操作的上界，然后累加后就可以得到总体开销小于势能函数 φ(T)。具体的数学证明就不给出了。

在随机情况下，splay树的均摊时间复杂度是 O(logN). 

在最坏情况下，splay树有可能会退化成链，在这种情况下，时间复杂度会变成 O(N), 但在随机数据中不会出现。

由于每一次操作都会将结点转到根处，操作频繁的节点会很靠近树根。因此如果在一个时间范围内，所要查询或修改的节点都是固定的几个，splay树的时间复杂度就会很低（接近常数），但是这是依赖于测试数据的。

#### 对于实践环节的两个插入序列，它们最后的产生的树的形态有什么区别？从插入序列看，原因是什么？

对第一个插入序列，树的形态更靠近一棵完全二叉树；对第二个插入序列，树的形态更接近链。这是因为第一个插入序列中的数字随机性更高，不太有规律可循；而第二个插入序列中的数字按一大一小分布，且基本上插入的都是在此之前的最小值或者最大值，这就导致了Splay树退化成类似于链的情况。如果插入序列是有序插入的话，退化的就会更明显。