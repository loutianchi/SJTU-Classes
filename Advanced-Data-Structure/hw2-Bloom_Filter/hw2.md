# HW2

### Bloom Filter的实现及实验设计

1. 使用已提供的 Hash 函数，使用返回的 hash[1] 的值
2. 用户输入 m/n 的值 与 k 的值，程序自动计算平均的误判率 (False Positive)。
3. 自动计算使用的数据为：从 50 到 100 000，每隔 50 取一个 n，并用提供的 m/n 的值计算出 m 的值。将 0 到 n -1 这些数据插入 Bloom Filter 中，并且 使用 n + 1 到 2n 的数据作为要查询的数据。最后输出平均的误判率。

### 实验数据与分析

进行实验，得到结果如下：

| m/n  | k（理论最优） | k=1  | k=2  | k=3  | k=4  | k=5  |
| ---- | :--: | :--: | :--: | :--: | :--: | :--: |
| 2    | 1.39          | 0.39369 | 0.39978 | - | - | - |
| 3    | 2.08          | 0.28355 | 0.23689 | 0.25260 | - | - |
| 4    | 2.77          | 0.22136 | 0.15497 | 0.14698 | 0.15974 | - |
| 5    | 3.46          | 0.18136 | 0.10878 | 0.09192 | 0.09200 | 0.10096 |

​		实验结果与给出的理论值符合的非常好，因为使用了大量的测试数据。在一开始使用的数据量较小时，与预期结果的趋势虽然保持一致，但是在结果数值方面的偏差还是较大的，因此采用了大数据量的测试以获取更加精确的结果。

​		从实验的结果中，可以看出，随着 m/n 这个数值的增大，误判率不断减小，这是因为哈希数组的增大，让冲突发生的可能减小，这是很直观的。但是，m/n 增加的代价就是空间开销的不断增加，因此需要在 m/n 的增加和误判率增加中取一个平衡的点，从而既有较低的误判率，同时也不占用太大的开销。

​		从实验的结果中也可以看出，k 的最优取值的确在 ln2 * (m/n) 的附近，偏离越远，误判率就会越高，这与计算的结论也是一致的。